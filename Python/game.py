def play():    '''(None) -> None    Take input from user for grid size    '''    #Asks user for grid size    grid_size = int(input("Please enter a grid size: "))    if grid_size != 4 and grid_size != 9 and grid_size != 16:        z = True        while z == True:            grid_size = int(input("You have entered an invalid grid size. Please enter a grid size: "))            if grid_size == 4 or grid_size == 9 or grid_size == 16:                z = False    N = grid_size    #Makes matrix for large grid and matrix for each smaller grid    matrix_maker(N)    #Prints initial grid    grid_maker(N)    #Asks Player for move    make_move()def check_move(row,column,number):    '''(int, int, int) -> bool    Return False for invalid input from user    '''        N = len(grid)    # checks if value out of range    if number > N:        return False    # checks if row is out of range    elif row > N - 1:        return False    # checks if value is in row    elif number in grid[row]:        return False    # checks if column out of range    elif column > N - 1:        return False    # checks if value is in column    for j in range(N):        if number == grid[j][column]:            return False        if j == N - 1:    # checks if value is in small grid            small_row = int((row)/int(N**0.5))            small_column = int(column/int(N**0.5))            for i in range(int(N**0.5)):                if number in small_grid[small_row][small_column]:                    return False                if i == int(N**0.5 - 1):    # checks if the small grid is already full                    if grid[row][column] != 0:                        return False                    else:                        return Truedef check_win():    '''(None) -> int    Return 0 for game to continue    Return 1 if a player wins game    Return 2 if games ends in a tie    '''        #Checks if game is over and who wins    M = len(grid)    test = [0]*3    for m in range(M):        for n in range(M):            for o in range(M):    #Tests if there are still possible moves for an open position                if grid[m][n] == 0:                    test[0] = int(m)                    test[1] = int(n)                    test[2] = int(o + 1)                    if check_move(test[0],test[1],test[2]) == True:                        return 0    #Checks if game ends in a tie                elif m == M - 1 and n == M - 1:                    v = 0                    for t in range(M):                        for u in range(M):                            if check_move(t,u,grid[t][u]) == False and grid[t][u] != 0:                                v += 1                                if v == int(M**2):                                    return 2                                    return 1def save():    '''(None) -> None    Save game to a file    '''        #Writes each line of the grid to a file to save game    #Takes matrix for entire grid and writes values to file in grid form    N = len(grid)    file_name = input("Please enter a file name or quit:")    if file_name == 'q':        return    file_text = open(file_name + '.txt', 'w')    for n in range(N):        display = ''        for l in range(N):            display += str(grid[n][l]) + ' '            if (l + 1) % int(N**0.5) == 0:                display = display.rstrip(' ') + '|'            if l == (N-1):                display = display.rstrip('|') + '\n'        if (n + 1) % int(N**0.5) == 0 and n != N - 1:            display += (N * 2 - 1) * '-' + '\n'        file_text.write(str(display))    file_text.close()def grid_maker(N):    '''(int) -> None    Print grid for game    '''        #Takes matrix for entire grid and prints it as a string for the grid    for n in range(N):        display = ''        for l in range(N):            display += str(grid[n][l]) + ' '            if (l + 1) % int(N**0.5) == 0:                display = display.rstrip(' ') + '|'            if l == (N-1):                display = display.rstrip('|')         if (n + 1) % int(N**0.5) == 0 and n != N - 1:            display += '\n' + (N * 2 - 1) * '-'         print(display)def matrix_maker(N):    '''(int) -> None    Take grid size and make matrix for large grid    and matrix for cluster    '''    #Makes matrix for entire grid    for i in range(N):        grid.append([])        for j in range(N):            grid[i].append(0)    #Makes matrix for clusters    for k in range(int(N**0.5)):        small_grid.append([])        for l in range(int(N**0.5)):            small_grid[k].append([0])def make_move():    '''(None) -> None    Take move input from user and puts inside grid    '''        N = len(grid)    #Asks Player for move    x = True    Player = 'A'    while x == True:        statement = input("Player " + Player + " please enter move:")    #Checks if player wants to save game        if statement == 's':            save()            return    #Checks if player wants to end game        if statement == 'q':            return        move = statement.split(', ')        for k in range(len(move)):            move[k] = int(move[k])    #Checks if move is valid        if check_move(move[0],move[1],move[2]) == True:    #Adds move to smaller grid matrix            small_row = int((move[0])/len(small_grid[0]))            small_column = int((move[1])/len(small_grid[0]))            small_grid[small_row][small_column].append(move[2])    #Adds move to larger grid matrix            grid[move[0]][move[1]] = move[2]    #Prints grid with new move added            grid_maker(N)            if check_win() == 1:                print("Player " + Player + " wins!")                save()                x = False            elif check_win() == 2:                print("It's a tie!")                save()                x = False            else:                if Player == 'A':                    Player = 'B'                else:                    Player = 'A'if __name__ == "__main__":    grid = []    small_grid = []    play()